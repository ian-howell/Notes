Ternary Operator
- Python versoin: expr if condition else expr2:
- C equivalent: condition ? expr : expr2
-------------------------------------------------------------------------------
Lambda Expressions
- Lambdas are anonymous functions
- They take 0 or more arguments and return a value

Syntax:
lambda [arglist]: expression
For example:
lambda x: x+1 # prettu useless...
f = lambda x: x+1
f(10) # returns 11
g = lambda x, y: x + y
g(5, 6) # also returns 11
h = lambda: "bob"
h() # returns "bob"
l = lambda x, y: m = x.values(); ... more stuff...; ... even more stuff... # NO
- Lambdas are frequently used when you need a function for a single puurpose
  and a single usage
  - As a function parameter
- DONT ABUSE THEM

# Assume Observation class doesn't have __lt__ implemented
obs = sorted(obs) # When obs is a list of observations,
# This causes an error
obs = sorted(obs, key = lambda x: x.time)

# We could also do this:
def get_time(o):
    return o.time
obs = sorted(obs, key=get_time)
# But that's dumb, so...
-------------------------------------------------------------------------------
Function Decorators
- Wraps functions to modify its behavior
- common in the Python std lib
- Commond in other Python libs
- DONT ABUSE THEM

# Example of wrapper
import time
def time_this(func):
    def wrapper(*args, **kwargs):
        Start = time.time() # current time
        retval = func(*args, **kwargs)
        Stop = time.time() # current time
        print("{} took {:0.3f} seconds".format(func.__name__, (Stop - Start)))
        return retval
    return wrapper


# Using it
def add5(val):
    time.sleep(1.2)
    return val + 5

add5 = time_this(add5)
add5(10) # returns 15
# Prints "add5 took 1.2 seconds"

@time_this # This line is the same as the last bit
def add10(val):
    time.sleep(2.3)
    return val + 10

- The @dec syntax is syntactic sugar for func = dec(func)
- You can stack multiple decorators
- Applying a decorator will clobber the name, docstring,
    etc of the wrapped function
- Makes things tricky to debug
- Easily remedied with functools.wrap()


@require_int
def add5(val):
    return val + 5
# We want to be sure that the argument has type `int`

import functools
def require_int(func):
    @functools.wrap(func)
    def wrapper(arg):
        if not isinstance(arg.int):
           raid TypeError("bad") 
        return func(arg)
    return wrapper
           
add5(10) # returns 15
add5(1.2) # Raises a TypeError: bad
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
